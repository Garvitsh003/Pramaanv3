'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var queueMicrotask = require('queue-microtask');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var queueMicrotask__default = /*#__PURE__*/_interopDefaultLegacy(queueMicrotask);

const mailbox = () => {
  const queue = [];
  var next;
  return {
    async deliver(msg) {
      queue.push(msg);
      if (next) {
        next(queue.shift());
        next = undefined;
      }
    },
    receive() {
      return new Promise(function innerReceive(resolve) {
        const msg = queue.shift();
        if (msg) return resolve(msg);
        next = resolve;
      });
    }
  };
};

const INIT = "INIT";
const SUBSCRIBE = "SUBSCRIBE";
const UNSUBSCRIBE = "UNSUBSCRIBE";
const UPDATED = "UPDATED";
const SNAPSHOT = "SNAPSHOT";
const EXIT = "EXIT";
const TERMINATE = "TERMINATE";
const root = typeof self === "object" && self.self === self && self || typeof global === "object" && global.global === global && global || typeof window === "object" && window.window === window && window;
root.FCL_REGISTRY = root.FCL_REGISTRY == null ? {} : root.FCL_REGISTRY;
var pid = 0b0;
const DEFAULT_TIMEOUT = 5000;
const send = function (addr, tag, data) {
  let opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  return new Promise((reply, reject) => {
    const expectReply = opts.expectReply || false;
    const timeout = opts.timeout != null ? opts.timeout : DEFAULT_TIMEOUT;
    if (expectReply && timeout) {
      setTimeout(() => reject(new Error(`Timeout: ${timeout}ms passed without a response.`)), timeout);
    }
    const payload = {
      to: addr,
      from: opts.from,
      tag,
      data,
      timeout,
      reply,
      reject
    };
    try {
      root.FCL_REGISTRY[addr] && root.FCL_REGISTRY[addr].mailbox.deliver(payload);
      if (!expectReply) reply(true);
    } catch (error) {
      console.error("FCL.Actor -- Could Not Deliver Message", payload, root.FCL_REGISTRY[addr], error);
    }
  });
};
const kill = addr => {
  delete root.FCL_REGISTRY[addr];
};
const fromHandlers = function () {
  let handlers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return async ctx => {
    if (typeof handlers[INIT] === "function") await handlers[INIT](ctx);
    __loop: while (1) {
      const letter = await ctx.receive();
      try {
        if (letter.tag === EXIT) {
          if (typeof handlers[TERMINATE] === "function") {
            await handlers[TERMINATE](ctx, letter, letter.data || {});
          }
          break __loop;
        }
        await handlers[letter.tag](ctx, letter, letter.data || {});
      } catch (error) {
        console.error(`${ctx.self()} Error`, letter, error);
      } finally {
        continue __loop;
      }
    }
  };
};
const spawn = function (fn) {
  let addr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  if (addr == null) addr = ++pid;
  if (root.FCL_REGISTRY[addr] != null) return addr;
  root.FCL_REGISTRY[addr] = {
    addr,
    mailbox: mailbox(),
    subs: new Set(),
    kvs: {},
    error: null
  };
  const ctx = {
    self: () => addr,
    receive: () => root.FCL_REGISTRY[addr].mailbox.receive(),
    send: function (to, tag, data) {
      let opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      opts.from = addr;
      return send(to, tag, data, opts);
    },
    sendSelf: (tag, data, opts) => {
      if (root.FCL_REGISTRY[addr]) send(addr, tag, data, opts);
    },
    broadcast: function (tag, data) {
      let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      opts.from = addr;
      for (let to of root.FCL_REGISTRY[addr].subs) send(to, tag, data, opts);
    },
    subscribe: sub => sub != null && root.FCL_REGISTRY[addr].subs.add(sub),
    unsubscribe: sub => sub != null && root.FCL_REGISTRY[addr].subs.delete(sub),
    subscriberCount: () => root.FCL_REGISTRY[addr].subs.size,
    hasSubs: () => !!root.FCL_REGISTRY[addr].subs.size,
    put: (key, value) => {
      if (key != null) root.FCL_REGISTRY[addr].kvs[key] = value;
    },
    get: (key, fallback) => {
      const value = root.FCL_REGISTRY[addr].kvs[key];
      return value == null ? fallback : value;
    },
    delete: key => {
      delete root.FCL_REGISTRY[addr].kvs[key];
    },
    update: (key, fn) => {
      if (key != null) root.FCL_REGISTRY[addr].kvs[key] = fn(root.FCL_REGISTRY[addr].kvs[key]);
    },
    keys: () => {
      return Object.keys(root.FCL_REGISTRY[addr].kvs);
    },
    all: () => {
      return root.FCL_REGISTRY[addr].kvs;
    },
    where: pattern => {
      return Object.keys(root.FCL_REGISTRY[addr].kvs).reduce((acc, key) => {
        return pattern.test(key) ? {
          ...acc,
          [key]: root.FCL_REGISTRY[addr].kvs[key]
        } : acc;
      }, {});
    },
    merge: function () {
      let data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      Object.keys(data).forEach(key => root.FCL_REGISTRY[addr].kvs[key] = data[key]);
    },
    fatalError: error => {
      root.FCL_REGISTRY[addr].error = error;
      for (let to of root.FCL_REGISTRY[addr].subs) send(to, UPDATED);
    }
  };
  if (typeof fn === "object") fn = fromHandlers(fn);
  queueMicrotask__default["default"](async () => {
    await fn(ctx);
    kill(addr);
  });
  return addr;
};

// Returns an unsubscribe function
// A SUBSCRIBE handler will need to be created to handle the subscription event
//
//  [SUBSCRIBE]: (ctx, letter) => {
//    ctx.subscribe(letter.from)
//    ctx.send(letter.from, UPDATED, ctx.all())
//  }
//
function subscriber(address, spawnFn, callback) {
  spawnFn(address);
  const EXIT = "@EXIT";
  const self = spawn(async ctx => {
    ctx.send(address, SUBSCRIBE);
    while (1) {
      const letter = await ctx.receive();
      const error = root.FCL_REGISTRY[address].error;
      if (letter.tag === EXIT) {
        ctx.send(address, UNSUBSCRIBE);
        return;
      }
      if (error) {
        callback(null, error);
        ctx.send(address, UNSUBSCRIBE);
        return;
      }
      callback(letter.data, null);
    }
  });
  return () => send(self, EXIT);
}

// Returns a promise that returns a result
// A SNAPSHOT handler will need to be created to handle the snapshot event
//
//  [SNAPSHOT]: (ctx, letter) => {
//    letter.reply(ctx.all())
//  }
//
function snapshoter(address, spawnFn) {
  spawnFn(address);
  return send(address, SNAPSHOT, null, {
    expectReply: true,
    timeout: 0
  });
}

exports.EXIT = EXIT;
exports.INIT = INIT;
exports.SNAPSHOT = SNAPSHOT;
exports.SUBSCRIBE = SUBSCRIBE;
exports.TERMINATE = TERMINATE;
exports.UNSUBSCRIBE = UNSUBSCRIBE;
exports.UPDATED = UPDATED;
exports.kill = kill;
exports.send = send;
exports.snapshoter = snapshoter;
exports.spawn = spawn;
exports.subscriber = subscriber;
//# sourceMappingURL=actor.js.map
