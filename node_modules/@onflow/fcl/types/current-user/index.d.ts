export function isFn(d: any): boolean;
export type CurrentUser = import("@onflow/typedefs").CurrentUser;
export type CompositeSignature = import("@onflow/typedefs").CompositeSignature;
export function currentUser(): {
    authenticate: typeof authenticate;
    unauthenticate: typeof unauthenticate;
    authorization: typeof authorization;
    signUserMessage: typeof signUserMessage;
    subscribe: typeof subscribe;
    snapshot: typeof snapshot;
    resolveArgument: typeof resolveArgument;
};
export namespace currentUser {
    export { authenticate };
    export { unauthenticate };
    export { authorization };
    export { signUserMessage };
    export { subscribe };
    export { snapshot };
    export { resolveArgument };
}
/**
 * @description - Authenticate a user
 * @param {object} [opts] - Options
 * @param {object} [opts.service] - Optional service to use for authentication
 * @param {boolean} [opts.redir=false] - Optional flag to allow window to stay open after authentication
 * @returns {Promise<CurrentUser>} - User object
 */
declare function authenticate({ service, redir }?: {
    service?: object;
    redir?: boolean;
}): Promise<CurrentUser>;
/**
 * @description - Unauthenticate a user
 * @returns {void}
 */
declare function unauthenticate(): void;
/**
 * @description
 * Produces the needed authorization details for the current user to submit transactions to Flow
 * It defines a signing function that connects to a user's wallet provider to produce signatures to submit transactions.
 *
 * @param {object} account - Account object
 * @returns {Promise<object>} - Account object with signing function
 */
declare function authorization(account: object): Promise<object>;
/**
 * @description - A method to use allowing the user to personally sign data via FCL Compatible Wallets/Services.
 * @param {string} msg - Message to sign
 * @returns {Promise<CompositeSignature[]>} - Array of CompositeSignatures
 */
declare function signUserMessage(msg: string): Promise<CompositeSignature[]>;
/**
 * @description
 * The callback passed to subscribe will be called when the user authenticates and un-authenticates, making it easy to update the UI accordingly.
 *
 * @param {Function} callback - Callback function
 * @returns {Function} - Unsubscribe function
 */
declare function subscribe(callback: Function): Function;
/**
 * @description - Gets the current user
 * @returns {Promise<CurrentUser>} - User object
 */
declare function snapshot(): Promise<CurrentUser>;
/**
 * @description - Resolves the current user as an argument
 * @returns {Promise<Function>}
 */
declare function resolveArgument(): Promise<Function>;
export {};
